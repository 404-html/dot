"
"  _  _ _ _  _ ____ ____
"  |  | | |\/| |__/ |
" . \/  | |  | |  \ |___
"
" available at github.com/krry/dot
"
" üßû krry

" _ _  _ _ ___ _ ____ _    _ ___  ____
" | |\ | |  |  | |__| |    |   /  |___
" | | \| |  |  | |  | |___ |  /__ |___

    " Pull in the plugins and prep the operating room
    if !has('nvim')
        set nocompatible            " always first, neovim doesn't need this
    endif

    if filereadable(expand('~/.vimrc.bundles'))
        source ~/.vimrc.bundles " Load ALL THE PLUGINS!!!
    endif
    filetype plugin indent on   " required after vim-plug
    set background=dark         " PaperColor responds
    syntax enable               " enable highlighting
    set encoding=utf-8          " one typeset to rule them all
    scriptencoding utf-8
    set t_co=256                " enable 256 colors
    set hidden                  " allow hidden buffers from plugins
    "
" ____ ____ ____ ____ _  _ ___ _ ____ _
" |___ [__  [__  |___ |\ |  |  | |__| |
" |___ ___] ___] |___ | \|  |  | |  | |___

    " Elect a new <leader>
        let mapleader = ','

    " Get a semi, save your pinky
    " https://nvie.com/posts/how-i-boosted-my-vim/
        nnoremap ; :

    " Help is on the K! It's a... man.
        augroup helpers
            autocmd!
            autocmd FileType vim setlocal keywordprg=:help
            " It's a lot more *helpful* when it's vertical.
            autocmd FileType help wincmd L
        augroup END

    " Edit .vimrc
        noremap <leader>ev :e ~/.dot/vimrc.symlink<cr>

    " Source .vimrc
        noremap <leader>sv :source $MYVIMRC<cr>
                     \:exe 'echo ".vimrc resourced"'<cr>

    " Save quickly
        noremap <C-s> :w<cr>
        inoremap <C-s> <esc>:w<cr>

    " Quit easily
        nnoremap <C-q> :q<cr>

    " Change directory to here
        cmap cwd lcd %:p:h

    " Really Write! - for when you forget to sudo (thx @spf13)
        cmap w!! w !sudo tee % >/dev/null

    " Be quiet
        set noerrorbells
        set visualbell
        "
    " Mouse
        set mouse=a                    " No need to be a homerow nazi
        set mousehide                  " Hide mouse when typing

    " Copy & Paste anywhere
        if has('clipboard')
            if has('unnamedplus')      " Ideally use + register as clipboard
                set clipboard=unnamed,unnamedplus
            else                         " Awnh, whatever, use the * register.
                set clipboard=unnamed    " Ought to be available on Mac or Win
            endif
        endif

        " Yank to the end of the line like C and D
            nnoremap Y y$
        " Extend substitute function with easyclip
            let g:EasyClipUseSubstituteDefaults = 1
        " Preserve mark making, while using `m` to move with vim-easyclip
            nnoremap gm m
        " Preserve jump back, while still making newlines above with <C-o>
            nnoremap <C-[> <C-o>
            "
    " Play nice with the shell
        set noswapfile
        set nobackup

        if &shell =~# 'fish$'
            set shell=bash               " VIm doesn't like fish.
        endif

" _ _  _ ___  ____ _  _ ___ ____ ___ _ ____ _  _
" | |\ | |  \ |___ |\ |  |  |__|  |  | |  | |\ |
" | | \| |__/ |___ | \|  |  |  |  |  | |__| | \|

    " A tab is four spaces, till it ain't.
    set tabstop=4                   " tabs are 4 spaces
    set softtabstop=4               " insert/<bs> use 4-space tabs
    set shiftwidth=4                " autoindent 4-space tabs
    set expandtab                   " autoindent with space-tabs
    set autoindent                  " according to previous line
    set smartindent                 " according to brackets and such

" ___ ____ ___  ____
"  |  |__| |__] [__
"  |  |  | |__] ___]
"
    " Some buffers are in tabs. Some tabs are in buffers.
    nmap <Tab> :tabnext<cr>
    nmap <C-Tab> :tabclose<cr>
    nmap <S-Tab> :tabprevious<cr>

" _    _ _  _ ____ ____
" |    | |\ | |___ [__
" |___ | | \| |___ ___]

    " What line am I on, anyway?
    set nowrap                      " leave lines intact by
    set number                      " shows line number
    if (exists('+colorcolumn'))     " make final column visible, but dark
        set colorcolumn=80
        highlight ColorColumn ctermbg=8
    endif

" _  _ _   _ ____ _ ____ _  _ ____
" |__|  \_/  | __ | |___ |\ | |___
" |  |   |   |__] | |___ | \| |___

    " Neat code is easier to read.
    set list                        " enables listchars to highlight whitespace
    set listchars=tab:‚Ä∫\ ,trail:‚Ä¢,extends:#,nbsp:. " highlight problematic whitespace
    set nomodeline                  " don't look for vim settings at the top

    " EasyAlign horizontal whitespace
    vnoremap <silent> <Enter> :EasyAlign<cr>

    "Zenroom+Goyo
    nnoremap <silent> <leader>z :Goyo<cr>

" ____ ____ ____ ____ ____ _  _
" [__  |___ |__| |__/ |    |__|
" ___] |___ |  | |  \ |___ |  |
"
    " Sane search defaults
    set hlsearch                   " highlight search matches
    set incsearch                  " search as you type
    set ignorecase                 " case insensitive search
    set smartcase                  " case sensitive when uc used
    set showmatch                  " show matching brackets/parenthesis

    " toggle search highlighting
    nmap <silent> <leader>/ :set invhlsearch<CR>

" ___  ____ _  _ _ ___ ____
" |  \ |___ |\ | |  |  |___
" |__/ |___ | \| |  |  |___

    " Denite fuzzy searches, launches, does all the things!

    " thx to sodiumjoe: https://github.com/sodiumjoe/dotfiles/blob/master/vimrc
    " custom prompt symbol
    call denite#custom#option('default', { 'prompt': '‚ùØ' })

    " to search for files
    call denite#custom#var('file_rec', 'command',
                \ ['ag', '--follow', '--nocolor', '--nogroup', '-u', '-g', ''])
                " -u flag to unrestrict (see ag docs)
    " to search in git files
    call denite#custom#var('file_rec/git', 'command',
                \ ['ag', '--follow', '--nocolor', '--nogroup', '-g', ''])
    " to search in files and git
    call denite#custom#alias('source', 'file_rec/git', 'file_rec')

    " to grep for contents
    call denite#custom#var('grep', 'command', ['rg'])
    call denite#custom#var('grep', 'default_opts',
          \ ['--hidden', '--vimgrep', '--smart-case'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'final_opts', [])

    call denite#custom#map('insert', '<Esc>', '<denite:enter_mode:normal>',
          \'noremap')
    call denite#custom#map('normal', '<Esc>', '<NOP>',
          \'noremap')
    call denite#custom#map('insert', '<C-v>', '<denite:do_action:vsplit>',
          \'noremap')
    call denite#custom#map('normal', '<C-v>', '<denite:do_action:vsplit>',
          \'noremap')
    call denite#custom#map('normal', 'dw', '<denite:delete_word_after_caret>',
          \'noremap')

    nnoremap <C-p> :<C-u>Denite file_rec<CR>
    nnoremap <leader>db :<C-u>Denite buffer<CR>
    nnoremap <leader>dbd :<C-u>DeniteBufferDir buffer<CR>
    nnoremap <leader>d* :<C-u>DeniteCursorWord grep:. -mode=normal<CR>
    nnoremap <leader>dg :<C-u>Denite grep:. -mode=normal<CR>
    nnoremap <leader>dbg :<C-u>DeniteBufferDir grep:. -mode=normal<CR>
    nnoremap <leader>df :<C-u>DeniteBufferDir file_rec<CR>
    nnoremap <leader>dr :<C-u>Denite -resume -cursor-pos=+1<CR>
    nnoremap <leader>d<C-r> :<C-u>Denite register:. -mode=normal<CR>
    " references source from LanguageClient
    nnoremap <leader>dlr :<C-u>Denite references -mode=normal<CR>

    hi link deniteMatchedChar Special

    call denite#custom#option('_', {
                \ 'auto_preview': v:true,
                \ 'vertical_preview': v:true,
                \})

" _  _ ____ _  _ ____ _  _ ____ _  _ ___
" |\/| |  | |  | |___ |\/| |___ |\ |  |
" |  | |__|  \/  |___ |  | |___ | \|  |

    " Tuneups and handy tricks for moving around
    " Cursor glides between lines, wrapped or not
        noremap j gj
        noremap k gk

    " Easier horizontal scroll
        map zl zL
        map zh zH

    " make a new line above or below w/o insert mode
        nmap <C-o> O<Esc>
        nmap <M-o> o<Esc>

        nmap √ò O<Esc>
        nmap √∏ o<Esc>

" _  _ ____ ___ ____ _  _ ____ _  _ ____ ____
" |\/| |___  |  |__| |\/| |  | |  | |___ |__/
" |  | |___  |  |  | |  | |__|  \/  |___ |  \

    " Metamover moves lines around with <M-h/j/k/l>
    " also maps these movements to the symbols they produce (Àô‚àÜÀö¬¨ = hjkl)
    " iTerm recognizes Option as Meta key, but other $TERMs may not
    nnoremap <M-h> <<
    nnoremap <M-j> :m .+1<CR>==
    nnoremap <M-k> :m .-2<CR>==
    nnoremap <M-l> >>

    nnoremap Àô <<
    nnoremap ‚àÜ :m .+1<CR>==
    nnoremap Àö :m .-2<CR>==
    nnoremap ¬¨ >>

    inoremap <M-h> <C-d>
    inoremap <M-j> <Esc>:m .+1<CR>==gi
    inoremap <M-k> <Esc>:m .-2<CR>==gi
    inoremap <M-l> <C-t>

    inoremap Àô <C-d>
    inoremap ‚àÜ <Esc>:m .+1<CR>==gi
    inoremap Àö <Esc>:m .-2<CR>==gi
    inoremap ¬¨ <C-t>

    vnoremap <M-h> <gv
    vnoremap <M-j> :m '>+1<CR>gv=gv
    vnoremap <M-k> :m '<-2<CR>gv=gv
    vnoremap <M-l> >gv

    vnoremap Àô <gv
    vnoremap ‚àÜ :m '>+1<CR>gv=gv
    vnoremap Àö :m '<-2<CR>gv=gv
    vnoremap ¬¨ >gv

" ____ _  _ ____ ____ ____ ____
" |    |  | |__/ [__  |  | |__/
" |___ |__| |  \ ___] |__| |  \

    " sane defaults for cursor, neovim defaults to some of them
    set backspace=indent,eol,start " allow backspace when inserting
    set cursorline                 " shows line cursor is on
    set whichwrap+=<,>,h,l,[,]     " wrap arrow keys between lines
    set scrolljump=5                " lines to scroll when cursor leaves screen
    set scrolloff=3                 " minimum lines to keep above and below cursor
    set foldenable                  " auto fold code

" _ _ _ _ _    ___  ____ _ ____ ____
" | | | | |    |  \ |___ | |__/ |___
" |_|_| | |___ |__/ |    | |  \ |___

    " fire grows, water shrinks

    " This selects the next closest text object.
    map <Space> <Plug>(wildfire-fuel)
    " This selects the previous closest text object.
    vmap <M-Space> <Plug>(wildfire-water)

" _ _ _ _ _  _ ___  ____ _ _ _ ____   |   ___  ____ _  _ ____ ____
" | | | | |\ | |  \ |  | | | | [__    |   |__] |__| |\ | |___ [__
" |_|_| | | \| |__/ |__| |_|_| ___]   |   |    |  | | \| |___ ___]

    " We like uniformity and accessibility
    set splitright                 " vertical splits go to the right
    set splitbelow                 " horizontal splits go below

    " windowpane navigation
    " same bindings as Tmux
        map <C-h> <C-w>h
        map <C-j> <C-w>j
        map <C-k> <C-w>k
        map <C-l> <C-w>l

" _  _ _ ____ _  _ ____ _       _  _ ____ ___  ____
" |  | | [__  |  | |__| |       |\/| |  | |  \ |___
"  \/  | ___] |__| |  | |___    |  | |__| |__/ |___

    " Enter visual mode
        nmap <enter> V

    " indent without leaving VISUAL mode
        vnoremap < <gv
        vnoremap > >gv

    " repeat operator with a visual selection (!)
        " http://stackoverflow.com/a/8064607/127816
        vnoremap . :normal .<CR>

" _  _ ____ ____ ___  ___ ____ ____ ____
" |\ | |___ |__/ |  \  |  |__/ |___ |___
" | \| |___ |  \ |__/  |  |  \ |___ |___

    " NERDTree makes navigating the filesystem a treat.
    set ttyfast                  " ensure fast terminal performance
    set lazyredraw

    nmap <leader>t :NERDTreeToggle<CR>
    nmap <leader>f :NERDTreeFind<CR>

    let g:NERDTreeDirArrowExpandable = '‚ñ∏'
    let g:NERDTreeDirArrowCollapsible = '‚ñæ'
    let g:NERDTreeQuitOnOpen = 1
    let g:NERDTreeAutoDeleteBuffer = 1
    let g:NERDTreeMinimalUI = 1
    let g:NERDTreeDirArrows = 1

    " open for directories
    augroup nerdtree
        autocmd!
        autocmd StdinReadPre * let s:std_in=1
        autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) &&
                    \ !exists("s:std_in") | exe 'NERDTree' argv()[0] |
                    \ wincmd p | ene | endif
    " close when last open
        autocmd BufEnter * if (winnr("$") == 1 &&
                    \ exists("b:NERDTreeType") &&
                    \ b:NERDTreeType == "primary") | q | endif
    augroup END

    let g:netrw_dirhistmax = 0        " don't save .netrwhist files

" ____ ____ _  _ _  _ ____ _  _ ___ ____
" |    |  | |\/| |\/| |___ |\ |  |  [__
" |___ |__| |  | |  | |___ | \|  |  ___]

    " NERDCommenter handles the comment symbology
    let g:NERDCommentEmptyLines = 1
    let g:NERDRemoveExtraSpaces = 1
    let g:NERDTrimTrailingWhitespace = 1
    let g:NERDCompactSexyComs = 1
    let g:NERDRemoveAltComs = 1
    let g:NERDSpaceDelims = 1

" ____ _  _ ____ _ ___ _ _  _ ____
" |___ |  | | __ |  |  | |  | |___
" |    |__| |__] |  |  |  \/  |___

    " Fugitive adds a git layer to vim
    if isdirectory(expand('~/.vim/bundle/vim-fugitive/'))
        nnoremap <silent> <leader>ga :Gwrite<cr>
        nnoremap <silent> <leader>gco :Gread<cr>
        nnoremap <silent> <leader>gc :Gcommit<cr>
        nnoremap <silent> <leader>gp :Gpush<cr>
        nnoremap <silent> <leader>gl :Gpull<cr>
        nnoremap <silent> <leader>gs :Gstatus<cr>
        nnoremap <silent> <leader>gd :Gvdiff<cr>
        nnoremap <silent> <leader>grm :Gremove<cr>
        nnoremap <silent> <leader>gmv :Gmove<cr>
        nnoremap <silent> <leader>gb :Gblame<CR>
        nnoremap <silent> <leader>glog :Glog<CR>
        nnoremap <silent> <leader>ge :Gedit<CR>
        nnoremap <silent> <leader>gi :Git add -p %<CR>
        nnoremap <silent> <leader>gg :SignifyToggle<CR>
    endif

" ____ _    ____
" |__| |    |___
" |  | |___ |___
"
    " Ale does the linting around these parts

    " ALE Key mapping
    nmap <leader>alet :ALEToggle<cr>
    nmap <leader>alegd :ALEGoToDefinition<cr>
    nmap <leader>alefr :ALEFindReferences<cr>

    " Ale does the linting
    " Error and warning signs.
    let g:ale_sign_error = '‚ìß'
    let g:ale_sign_warning = '‚ö†'
    let g:ale_sign_info = '‚ÑπÔ∏é'
    let g:ale_linters = {
      \ 'go':  ['gofmt'],
      \ 'python': ['flake8', 'pyls'],
      \ 'rust': ['cargo', 'rls', 'rustfmt'],
      \ }
    " let g:ale_linters = {'html': ['jshint', 'hugo']}
    " let g:ale_linters = {'javascript': ['eslint']}
    " let g:ale_linters = {'javascript': []}
    " let g:ale_linters = {'c': 'all'}
    "
    " enable all linters for the filetype
    let b:ale_linters = 'all'
    let g:ale_linters_ignore = {'python': ['pylint']}

    " let g:ale_linters = {'c': 'all'}
    " let g:airline#extensio=column_color = 1
    " highlight ALESignColumnWithErrors ctermbg=176 ctermfg=16
    " highlight ALESignColumnWithoutErrors ctermbg=176 ctermfg=16

    let g:ale_list_vertical = 1             " open loclist/quickfix vertically
    let g:ale_echo_cursor = 1               " echo error when cursed
    let g:ale_lint_delay = 250              " default 200
    let g:ale_cursor_detail = 1             " show preview window when cursed
    let g:ale_close_preview_on_insert = 1   " close preview when ya fix it
    " let g:ale_completion_enabled = 1        " may overlap with deoplete

    " to lint JSX and embedded styles and scripts
    let g:ale_linter_aliases = {'html': ['html', 'javascript', 'css']}

    " let g:ale_fixers = {'python': ['bar'], 'html': [], '*': ['foo']}
    " let g:ale_fix_on_save = 1
    " let g:ale_completion_delay = 100                  " default 100
    " let g:ale_completion_max_suggestions = 100        " default 50
    " let g:ale_completion_excluded_words = ['it', 'describe']

    " Go linting options
    " let g:ale_go_go_options = 'go'

    " Python linting options
    " let g:ale_python_auto_pipenv = 3
    "
    " Rust linter options
    let g:ale_rust_cargo_use_clippy = executable('cargo-clippy')
    let g:ale_rust_rls_toolchain = 'stable'  " change to 'nightly' when avails
    " let g:ale_rust_rustfmt_options = ''

    let g:ale_vim_vint_show_style_issues = 1

" ___  ____ ____ ___  _    ____ ___ ____
" |  \ |___ |  | |__] |    |___  |  |___
" |__/ |___ |__| |    |___ |___  |  |___

    " Deoplete completes from language servers and snippets
    if has('nvim')

        " get deoplete going on launch
        let g:deoplete#enable_at_startup = 1

        function! ConfigureDeoplete()

            " go left to get out of popup
            inoremap <expr><C-h> deoplete#cancel_popup()

            inoremap <expr><C-g> deoplete#refresh()

            " go right <C-l> to extend popup
            inoremap <silent><expr><C-l> deoplete#complete_common_string()

            " if popup showing, close popup
            inoremap <silent><expr><cr> pumvisible() ? deoplete#close_popup()
            \ : (delimitMate#WithinEmptyPair() ?
            \ "\<C-R>=delimitMate#ExpandReturn()\<CR>" : "\<CR>")

            " to switch deoplete on and off
            nmap <leader>dpl deoplete#toggle()

        endfunction

        call ConfigureDeoplete()

        " set deoplete options
        call deoplete#custom#option({
            \ 'smart_case': v:true,
            \ 'camel_case': v:true,
            \ 'auto_refresh_delay': 10,
            \ 'min_pattern_length': 1,
            \ 'auto_complete': v:true,
            \ })
        " \ 'auto_complete_delay': 250,

        " don't autocomplete my comments, deo
        call deoplete#custom#source('_',
                    \ 'disabled_syntaxes', ['Comment'])

    endif

" _  _ _ _  _ _ _ _ _ _  _ _
" |  | | |\/| | | | | |_/  |
"  \/  | |  | |_|_| | | \_ |

    " Vimwiki links notes together and publishes them to web
    let wiki = {}
    " set wiki to store in Google Drive
    let wiki.path = '~/Drive/Code/wiki/'
    let wiki.path_html = '~/Drive/Code/wiki/html/'
    let wiki.css_name = 'css/wiki.css'
    let wiki.auto_export = 1

    let g:vimwiki_list = [wiki]

" ____ _ ____ _    ____ ___
" |___ | | __ |    |___  |
" |    | |__] |___ |___  |

    " FIGlet converts a comment heading into a chuckle
    nmap <leader>hh3 <leader>cu^d0vg_:FIGlet -f threepoint<cr>V2j<leader>cl
    nmap <leader>hha <leader>cu^d0vg_:FIGlet -f amc3line<cr>V3j<leader>cl
    nmap <leader>hhm <leader>cu^d0vg_:FIGlet -f cybermedium<cr>V3j<leader>cl
    nmap <leader>hh4 <leader>cu^d0vg_:FIGlet -f 4max<cr>V3j<leader>cl
    nmap <leader>hhl <leader>cu^d0vg_:FIGlet -f computer<cr>V6j<leader>cl

" ____ ____ _    ____ ____ ____ ____ _  _ ____ _  _ ____
" |    |  | |    |  | |__/ [__  |    |__| |___ |\/| |___
" |___ |__| |___ |__| |  \ ___] |___ |  | |___ |  | |___

    " Colorscheme makes it okay to stare a a screen all day.
    colorscheme PaperColor
    "colorscheme molokai
    "colorscheme Apprentice
    "
    " better to set colorscheme at the bottom
    " to apply it to all preceding additions

    " then override anything you don't like
    highlight LineNr ctermbg=bg ctermfg=darkgray
    highlight Folded cterm=bold ctermfg=black ctermbg=240
    highlight clear signcolumn

" ____ ___  ___  ____ ____ _  _ ____
" |__| |__] |__] |__/ |___ |  | [__
" |  | |__] |__] |  \ |___  \/  ___]

    " Abbrevs autofill as you type in INSERT mode.
    iab <expr> hugotime strftime("%Y-%m-%dT%H:%M%:%S%z")
    iab <expr> w3time strftime("%FT%T%z")
    iab <expr> nowtime strftime("%c")

" ____ ____ _    ___  _ _  _ ____
" |___ |  | |    |  \ | |\ | | __
" |    |__| |___ |__/ | | \| |__]

    " Folding keeps code tidy and readable.
    augroup vimmers
        autocmd!
        autocmd Filetype vim setlocal foldenable
        autocmd Filetype vim setlocal foldmethod=indent
    augroup END

" ____ ___ ____ ____ ____
" |     |  |__| | __ [__
" |___  |  |  | |__] ___]

    " Tags track identifiers across files
    nmap <C-t> :TagbarToggle<cr>

    " might need to run `npm install` from this
    " to get JS to tag: https://github.com/ternjs/tern_for_vim
    " Javascript
    let g:tagbar_type_javascript = {
          \ 'ctagstype': 'javascript',
          \ 'kinds': [
          \ 'A:arrays',
          \ 'P:properties',
          \ 'T:tags',
          \ 'O:objects',
          \ 'G:generator functions',
          \ 'F:functions',
          \ 'C:constructors/classes',
          \ 'M:methods',
          \ 'V:variables',
          \ 'I:imports',
          \ 'E:exports',
          \ 'S:styled components'
          \ ]}

    " Markdown
    let g:tagbar_type_markdown = {
        \ 'ctagstype' : 'markdown',
        \ 'kinds' : [
            \ 'h:Heading_L1',
            \ 'i:Heading_L2',
            \ 'k:Heading_L3'
        \ ]
    \ }

    " Rust
     let g:tagbar_type_rust = {
        \ 'ctagstype' : 'rust',
        \ 'kinds' : [
            \'T:types,type definitions',
            \'f:functions,function definitions',
            \'g:enum,enumeration names',
            \'s:structure names',
            \'m:modules,module names',
            \'c:consts,static constants',
            \'t:traits',
            \'i:impls,trait implementations',
        \]
        \}

    " R
    let g:tagbar_type_r = {
        \ 'ctagstype' : 'r',
        \ 'kinds'     : [
            \ 'f:Functions',
            \ 'g:GlobalVariables',
            \ 'v:FunctionVariables',
        \ ]
    \ }

    " Go
    let g:tagbar_type_go = {
        \ 'ctagstype': 'go',
        \ 'kinds' : [
            \'p:package',
            \'f:function',
            \'v:variables',
            \'t:type',
            \'c:const'
        \]
    \}

    " CSS
    let g:tagbar_type_css = {
    \ 'ctagstype' : 'Css',
        \ 'kinds'     : [
            \ 'c:classes',
            \ 's:selectors',
            \ 'i:identities'
        \ ]
    \ }

    "
